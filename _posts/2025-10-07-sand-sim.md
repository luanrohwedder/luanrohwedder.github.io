---
title: Sand Simulator utilizando o raylib
date: 2025-10-07
categories: [Gamedev, Raylib]
tags: [gamedev, raylib, sand simulator, C]
image: /assets/img/2025-10-07/raylib_sandsim.png
---

Já tem um bom tempo que eu estava com vontade de fazer um sand simulator, não lembro o motivo de eu ter me fixado com isso, mas eu estava com muita vontade de tentar implementar isso. No começo, pensei em fazer utilizando OpenGL puro, e talvez por causa disso enrolei um pouco pra botar a mão na massa. Foi então que eu fiquei sabendo do [Raylib](https://www.raylib.com/), uma lib principalmente para fazer jogos. Ele abstrai bastante as coisas que eu teria que implementar do zero utilizando o OpenGL (sim, eu já fiz isso), e torna o processo de fazer jogo mais simples. Entretanto, não é tão simples assim, diferente de uma Unity, Godot, GameMaker, etc., não tem uma interface visual, e tudo deve ser feito codando!

Agora sem enrolação, vou apresentar desde a instalação do Raylib, até o que eu consegui fazer do sand simulator.

## Intalação do Raylib

### Dependências

Para instalar o Raylib, basta seguir a documentação para a sua plataforma específica, no meu caso, Arch Linux. Ele contém algumas dependências, então antes de instalar, foi preciso instalar as seguintes dependências:

```bash
sudo pacman -S alsa-lib mesa libx11 libxrandr libxi libxcursor libxinerama
```

Como o meu sistema é Wayland, e não X11, foi preciso instalar algumas outras dependências:

```bash
sudo pacman install wayland-devel libxkbcommon-devel wayland-protocols-devel
```

### Build

Antes de fazer o build do Raylib, como estou utilizando wayland, é preciso alterar uma flag no Makefile do projeto (ou do CMake, depende do que usar para compilar). Assim, basta clonar o projeto, alterar a flag do wayland e então compilar.

```bash
git clone --depth 1 https://github.com/raysan5/raylib.git raylib
cd raylib/src/
make PLATFORM=PLATFORM_DESKTOP
```

Dessa forma vai gerar lib estática, como descrito na Wiki. Aqui eu poderia copiar os arquivos gerados e incluir no meu projeto, ou então instalar de forma global para o sistema. Na hora eu não sabia muito bem o que eu estava fazendo, então acabei por instalar para o sistema todo, executando:

```bash
sudo make install
```

Assim termina a parte de instalação, bem simples, nada complexo.


## Fazendo o Sand Simulator

### Entendo o Raylib

Antes de tudo, eu precisava entender como funcionar o Raylib, e ele é bem simples. O Raylib trabalha com um [cheatsheet](https://www.raylib.com/cheatsheet/cheatsheet.html), que é uma planilha que mostra todos os métodos que existem, de forma que, os nomes do métodos são bem auto explicativo, facilitando a busca. Além do da planilha, ele também tem uma página de exemplos, que é útil para entender algumas coisas básicas dele. Sabendo disso, bastou ver um exemplo qualquer que já fica fácil de entender como funciona.

Para quem já programou com OpenGL, vai ter facilidade de entender. Primeiro criamos uma janela, depois dentro do loop principal do jogo, colocamos as coisas que precisam de atualização (inputs, física, etc.), e também faz o desenho dentro do BeginDrawing() e EndDrawing(), que delimita a área de atualizar a parte gráfica do jogo. Então um exemplo simples, apenas para abrir uma janela com um fundo branco seria assim:

```C
#include "raylib.h"

int main(void)
{
    const int width = 800;
    const int height = 450;

    InitWindow(width, height, "Exemplo de janela");
    SetTargetFPS(60);

    while (!WindowShouldClose())
    {
        BeginDrawing();
            ClearBackground(RAYWHITE);
        EndDrawing();
    }

    CloseWindow();

    return 0;
}
```

### Particle genérico

Para fazer o simulador, eu não queria implementar apenas a areia, então precisava de algo genérico que poderia ser "herdado" para todas as outras partículas que eu estava querendo criar. Para isso, foi feito um struct Particle, que contém dados genéricos de qualquer objeto que eu venha implementar depois. Além de criar a struct, foi feito alguns métodos que qualqeur partícula usa, como verificar os seus lados, trocar partículas, etc., e métodos core como Update e Draw, que é chamado no Main Loop. Assim ficou o arquivo de Particle:

```c
typedef enum
{
    EMPTY = 0,
    SAND = 1,
    WATER = 2,
    STONE = 3,
} Particles;

typedef struct Particle Particle;

struct Particle
{
    int type;
    Color color;
    int lastDir;
    void (*behavior)(Particle **grid, int x, int y);
};

bool isEmpty(Particle **grid, int x, int y);
bool verifyDown(Particle **grid, int x, int y, int type);
bool verifyDiagonal(Particle **grid, int x, int y, int type, int direction);
bool verifySide(Particle **grid, int x, int y, int type, int direction);
void swapParticle(Particle **grid, int x1, int y1, int x2, int y2);
char *getParticleString(int type);

void UpdateParticle(Particle **grid);
void DrawParticle(Particle **grid);
```

Dessa forma temos o core das partículas. Veja que na struct, há um atributo void, que é o comportamento daquela partícula específica, que deve ser implementado por ela mesmo, a ao criar uma partícula, atribuímos a função de comportamento criado para esse atributo, criando um falso polimorfismo, útil na hora de fazer Update.


### Grid e o comportamento do jogo

O jogo vai funcionar dentro de um grid, em uma janela de 1280x720, com célula de tamanho 5, ou seja, 1280/5 e 720/5, iremos ter 256 colunas e 144 linhas. O grid é bem simples, é uma matriz de Particle, contendo informação da cor, tipo, etc. Dessa forma, tudo é em volta desse grid, como pode ver anteriormente, onde todas as funções tem ele como um parâmetro.

### Implementando areia

Com o core feito, agora basta focar no comportamento de cada partícula. Para a areia é bem simples, primeiro, verificamos se existe um espaço livre em baixo dela, caso exista, desce uma posição, fazendo isso até encontrar um chão. Se não existir mais a possibilidade de descer, verifica as diagonais para baixo, da esquerda e direita, descendo no que estiver livre. Caso os dois seja livre, escolhe um de forma aleatória.

![Funcionamento da areia](/assets/img/2025-10-07/sand.png)
_Funcionamento básico de uma areia_

```c
void SandBehavior(Particle **grid, int x, int y)
{
    if (y + 1 >= ROWS)
        return;

    // DOWN
    if (verifyDown(grid, x, y, EMPTY) || verifyDown(grid, x, y, WATER))
    {
        swapParticle(grid, x, y, x, y + 1);
    }
    else if (grid[y + 1][x].type != STONE)
    {
        int dir = 0;
        bool canRight = false;
        bool canLeft = false;

        // RIGHT
        if (verifyDiagonal(grid, x, y, EMPTY, 1) ||
            verifyDiagonal(grid, x, y, WATER, 1))
            canRight = true;
        // LEFT
        if (verifyDiagonal(grid, x, y, EMPTY, -1) ||
            verifyDiagonal(grid, x, y, WATER, -1))
            canLeft = true;

        if (canRight && canLeft)
            dir = GetRandomValue(0, 1) == 0 ? -1 : 1;
        else if (canRight)
            dir = 1;
        else if (canLeft)
            dir = -1;

        if (dir != 0)
            swapParticle(grid, x, y, x + dir, y + 1);
    }
}
```

Esse é o comportamento da areia, podendo ter algumas alterações caso exista outras partículas, mas por enquanto, apenas isso.

### Implementando pedra

A pedra é bem simples, basta instanciar ela no grid. Como ela é uma partícula estática, não tem comportamento (por agora, vai que ela precisa se comportar de outra forma).

### Implementando água

A água é uma das coisas que ainda pretendo melhorar, o comportamento dela não me agrada ainda. Primeiro que eu precisei criar um atributo específico para ela no struct (o lastDir). Mas vamos falar como ela funciona primeiro, dessa vez sem imagem (fiquei com preguiça). 

O funcionamento da água a princípio é igual o da areia, verifica se pode descer, depois verifica se pode escorrer para o lado. O que diferencia ela da areia, é que quando está em uma superfície que não pode cair (tanto para baixo quanto para as diagonais), ele escorre para os lados, e é esse comportamento de escorrer para os lados que me deu trabalho.

Para simular melhor a água, eu tentei gravar a última posição que ela foi (esquerda ou direita), assim ele não fica fazendo se tremendo, e tenta manter uma certa aleatoriedade, pois se eu decido que ela vai para a esquerda primeiro, ele sempre vai para esquerda. Resumindo, implementei mas não gostei do resultado.


```c
void WaterBehavior(Particle **grid, int x, int y)
{
    //ANTES - Praticamente o mesmo da areia

    if (grid[y][x].lastDir != 0)
    {
        int dir = grid[y][x].lastDir;
        int nx = x + dir;

        if (verifySide(grid, x, y, EMPTY, dir))
        {
            swapParticle(grid, x, y, nx, y);
            grid[y][nx].lastDir = dir;
            return;
        }
        else
        {
            dir *= -1;
            nx = x + dir;

            if (verifySide(grid, x, y, EMPTY, dir))
            {
                swapParticle(grid, x, y, nx, y);
                grid[y][nx].lastDir = dir;
                return;
            }
            else
            {
                grid[y][x].lastDir = 0;
                return;
            }
        }
    }

    bool canRight = false;
    bool canLeft = false;

    if (verifySide(grid, x, y, EMPTY, 1))
        canRight = true;
    if (verifySide(grid, x, y, EMPTY, -1))
        canLeft = true;

    if (canRight && canLeft)
    {
        int dir = GetRandomValue(0, 1) == 0 ? -1 : 1;
        swapParticle(grid, x, y, x + dir, y);
        grid[y][x + dir].lastDir = dir;
        return;
    }
    else if (canRight)
    {
        swapParticle(grid, x, y, x + 1, y);
        grid[y][x + 1].lastDir = 1;
        return;
    }
    else if (canLeft)
    {
        swapParticle(grid, x, y, x - 1, y);
        grid[y][x - 1].lastDir = -1;
        return;
    }
}
```

### Resultado

Com essas 3 partículas, já dá pra brincar um pouco. Para poder usar todas elas, criei um interface simples (apenas texto), mostrando qual tecla deve clicar para selecionar a partícula desejado, e qual está selecionado no momento,e também uma tecla para limpar toda a tela. Com isso em mãos, já temos um simulador de areia (partícula) simples!

![Simulador de areia simples](/assets/img/2025-10-07/results1.gif)

### Melhorias simples!

Muita coisa que eu vejo em desenvolvimento de jogos são os polimentos (polish), que é basicamente melhorias simples, mas que mudam totalmente a cara do jogo. Eu quis fazer parecido, que era melhorar as cores das partículas. Cada partícula tinha apenas uma cor, ficando bem sem graça. O que eu fiz foi simplesmente adicionar uma paleta de cores para cada partícula, e quando for instanciar, escolhe da paleta de cores, uma cor aleatória. Uma melhoria simples, mas que mudou *MUITO* o simulador. 

Além disso, implementai uma função de pincel, onde pode se escolher um tamanho entre 1 e 5, que basicamente é a área que irá ser instanciado as partículas (1x1, 2x2, etc.). Eis então o resultado final.

![Simulador de areia simples melhorado](/assets/img/2025-10-07/results2.gif)

## Melhorias para o futuro

Não quero acabar esse simulador por aqui, quero adicionar mais coisas, mais partículas, melhorar o UI, etc. Então para o futuro, pretendo fazer o seguinte:

- Melhorar o comportamento da água
- Melhorar a UI
- Adicionar Madeira 
- Adicionar fogo, que interage com madeira

Para o próximo post sobre o Sand Simulator, quero ter implementado pelo menos essas 4 coisas. No mais, o link para o github está [aqui](https://github.com/luanrohwedder/falling-sand-simulation). Possivelmente o próximo post ainda será sobre o simulador, estou bem motivado para melhorar ele. No mais, até a próxima.
