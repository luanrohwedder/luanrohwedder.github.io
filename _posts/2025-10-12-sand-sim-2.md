---
title: Sand Simulator utilizando o raylib - Parte 2
date: 2025-10-12
categories: [Gamedev, Raylib]
tags: [gamedev, raylib, sand simulator, C]
image: /assets/img/2025-10-12/raylib_sandsim_2.png
---

Anteriormente no último [post]({% post_url 2025-10-07-sand-sim %}), eu comecei um projeto de sand simulator, que até então tinha apenas areia, água e pedra. No final do post, eu disse que que queria adicionar madeira e fogo, melhorar a UI e a água. Desses citados, apenas a água eu não consegui melhorar, e me contentei com o que eu fiz. Então sem enrolar muito, vou apresentar o que foi feito.

## Melhorias

### Botões

A primeira coisa que eu fiz foi tentar melhorar a UI, e para isso resolvi adicionar botões para selecionar as partículas (mantendo as teclas), de forma a tentar ocupar menos espaço vertical, e ocupar mais o espaço horizontal no topo, que estava sobrando. Como o Raylib não tem uma primitiva de botão, era necessário primeiro fazer um objeto botão:

```c
#ifndef BUTTON_H
#define BUTTON_H

#include <raylib.h>
#include <stdbool.h>

typedef struct
{
    Rectangle rect;
    Color color;
    char *text;
} Button;

Button CreateButton(Rectangle rect, Color color, char *text);

bool IsMouseOverButton(Button button);

bool IsButtonPressed(Button button);

#endif // !BUTTON_H
```

O botão tem um Rectangle para saber seu tamanho e lidar com colisões. Além disso, possuí uma cor e um texto, que é exibido quando o mouse está em cima. Para ter as funcionalidades de um botão, também foram criados métodos como IsMouseOverButton e IsButtonPressed, que verificar se o mouse está em cima e se o botão foi clicado, respectivamente. Dessa forma, para criar um botão basta chamar o método CreateButton e passar os parâmetros necessários. De forma resumida, na main ficou mais ou menos assim:

```c

// Draw Rectangle
DrawRectangleRec(buttons[i].rect, buttons[i].color);

// Draw Border
DrawRectangleLinesEx(buttons[i].rect, 1, RAYWHITE);

// Draw Tooltip
if (IsMouseOverButton(buttons[i]))
  DrawText(buttons[i].text, buttons[i].rect.x, buttons[i].rect.y + 30,
           15, RAYWHITE);

// Create Button
buttons[0] =
        CreateButton((Rectangle){.x = 250, .y = 20, .height = 20, .width = 20},
                     YELLOW, "SAND");

// Select
    if (IsButtonPressed(buttons[0]) || IsKeyPressed(KEY_ONE))
        selectedParticle = SAND;
```

![Botões](/assets/img/2025-10-12/buttons.png)
_Resultado final da implementação dos botões_

### Implementando madeira

Com a chegada da madeira e do fogo, eu precisei adicionar um novo atributo ao Particle, que é o _lifeTime_. A madeira terá um tempo de vida quando entrar em contato com o fogo, se não, ele comporta como uma partícula rígida, igual a pedra. Além disso, para ficar mais interessante, quando a madeira pega fogo, ele vai alterando sua cor de acordo com o tempo restante de vida, e, durante uma janela de tempo em que está pegando fogo, ele tem 1% de chance de passar o fogo para uma direção aleatória.

```c
void WoodBehavior(Particle **grid, int x, int y)
{
    if (grid[y][x].lifeTime > 0)
    {
        grid[y][x].lifeTime -= GetFrameTime();

        float t = grid[y][x].lifeTime;
        float r = GetRandomValue(0, 1000) / 1000.0f;
        if (r < 0.1f && (t > 0.9f && t < 1.3f))
        {
            int xDir = GetRandomValue(-1, 1);
            int yDir = GetRandomValue(-1, 1);
            int nx = x + xDir;
            int ny = y + yDir;

            if (IsParticle(grid, nx, ny, WOOD) && grid[ny][nx].lifeTime == 0)
                grid[ny][nx].lifeTime = 1.5f;
        }
    }

    if (grid[y][x].lifeTime < 0)
    {
        grid[y][x] = (Particle){0};
        return;
    }

    float t = grid[y][x].lifeTime;

    if (t > 1.0f)
        grid[y][x].color = BROWN;
    else if (t > 0.6f)
        grid[y][x].color = ORANGE;
    else if (t > 0.3f)
        grid[y][x].color = RED;
    else if (t > 0)
        grid[y][x].color = DARKGRAY;
}
```

Fiquei bem satisfeito com o comportamento da madeira, a interação com o fogo está muito boa. Única coisa que não gostei tanto assim foi as cores de transição enquanto ele queima, mas foi o que consegui fazer utilizando as paleta de cores padrão do Raylib (preguiça de colocar a própria cor).

### Implementando fogo

O fogo foi bem simples de fazer, e seu comportamento também é simples. Ele também tem um tempo de vida, bem curto, e ao interagir com a madeira, é apagado, mas coloca fogo na madeira. Além disso, para ficar mais realista, ele tem movimentos aleatórios, com maior probabilidade de apenas ir para cima, mas também de ir para todas as direções, com menor prababilidade.

```c
void FireBehavior(Particle **grid, int x, int y)
{
    if (y < 0 || y >= ROWS)
        return;

    grid[y][x].lifeTime -= GetFrameTime();

    if (grid[y][x].lifeTime <= 0)
    {
        grid[y][x] = (Particle){0};
        return;
    }

    if (grid[y][x].lifeTime < 0.3f)
    {
        float r = GetRandomValue(0, 1000) / 1000.f;

        if (r < 0.7f)
            grid[y][x].color = GOLD;
        else if (r < 0.95f)
            grid[y][x].color = ORANGE;
        else
            grid[y][x].color = RED;
    }
    else if (grid[y][x].lifeTime < 0.6f)
    {
        float r = GetRandomValue(0, 1000) / 1000.f;

        if (r < 0.40)
            grid[y][x].color = GOLD;
        else if (r < 0.70)
            grid[y][x].color = ORANGE;
        else
            grid[y][x].color = RED;
    }
    else
    {
        float r = GetRandomValue(0, 1000) / 1000.f;

        if (r < 0.10)
            grid[y][x].color = GOLD;
        else if (r < 0.50)
            grid[y][x].color = ORANGE;
        else
            grid[y][x].color = RED;
    }

    float r = GetRandomValue(0, 1000) / 1000.f;
    int nx = x;
    int ny = y;

    if (r <= 0.6f)
        ny -= 1;
    else if (r < 0.75f)
    {
        ny -= 1;
        nx -= 1;
    }
    else if (r < 0.90)
    {
        ny -= 1;
        nx += 1;
    }
    else if (r < 0.95)
        nx -= 1;
    else
        nx += 1;

    if (IsEmpty(grid, nx, ny))
    {
        SwapParticle(grid, x, y, nx, ny);
        return;
    }

    if (IsParticle(grid, nx, ny, WOOD))
    {
        grid[ny][nx].lifeTime = 1.5f;
    }
}
```

### Resultado

Dessa forma, melhorando um pouco a UI, e adicionando a madeira e o fogo, que adicionaram novas features para as partículas (com o lifetime), obtivemos um simulador um pouco mais interessante, ainda com pouco elemento para brincar (apenas 5).

![Simulador de areia simples v2](/assets/img/2025-10-12/resultsv2.gif)

## Melhorias para o futuro?

Com esse último resultado, eu fiquei bastante satisfeito com o que eu consegui fazer. Dá para adicionar uma infinidade de partículas, mas por agora, acho que já está bom. Era apenas um projeto piloto para aprender Raylib e tirar essa vontade que eu tinha de fazer um sand sim. Agora quero focar em um jogo de fato, talvez fazer clone de um snake, flappy bird, etc. Em algum momento quero fazer uma mini engine com o Raylib, no quesito de ter botões, um sound manager, etc., algo nesse estilo. No mais, esse projeto está finalizado.
